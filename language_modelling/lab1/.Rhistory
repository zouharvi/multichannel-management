length(okusers)
dat[dat$newID == 1,]
# subset the data
tmpdat = subset(dat, newID %in% okusers)
# The variable NativeLg is to check who is a native speaker and who is not. In the practice data set, 1 is coded for YES, 2 for NO
# TASK3: Check if there are non-native speakers using the table command and extracting the information about Lang variable
################################################################################################################################
table(dat$NatieLg)
# The variable NativeLg is to check who is a native speaker and who is not. In the practice data set, 1 is coded for YES, 2 for NO
# TASK3: Check if there are non-native speakers using the table command and extracting the information about Lang variable
################################################################################################################################
table(dat$NativeLg)
# The variable NativeLg is to check who is a native speaker and who is not. In the practice data set, 1 is coded for YES, 2 for NO
# TASK3: Check if there are non-native speakers using the table command and extracting the information about Lang variable
################################################################################################################################
table(dat[NativeLg,newID])
# The variable NativeLg is to check who is a native speaker and who is not. In the practice data set, 1 is coded for YES, 2 for NO
# TASK3: Check if there are non-native speakers using the table command and extracting the information about Lang variable
################################################################################################################################
table(dat[c("NativeLg", "newID")])
# The variable NativeLg is to check who is a native speaker and who is not. In the practice data set, 1 is coded for YES, 2 for NO
# TASK3: Check if there are non-native speakers using the table command and extracting the information about Lang variable
################################################################################################################################
table(unique(dat[c("NativeLg", "newID")])$nativeLg)
# The variable NativeLg is to check who is a native speaker and who is not. In the practice data set, 1 is coded for YES, 2 for NO
# TASK3: Check if there are non-native speakers using the table command and extracting the information about Lang variable
################################################################################################################################
table(unique(dat[c("NativeLg", "newID")])$NativeLg)
# Condition a is a sentence without each with a collective picture
# Condition b is a sentence with each with a collective picture
# Condition c is a sentence without each with a distributive picture
# Condition d is a sentence with each with a distributive picture
# Condition e is a filler
# Condition f is a control
# You need to remove controls and fillers from the data set because you are not interested in those responses.
# Make a new copy of the data set with cleaner data
# BTW what's the best thing about Switzerland? I think it's the flag. It's a big plus. (Haha! But seriously
# read all the instructions.)
summary(dat)
# subset the data
dat = subset(dat, newID %in% okusers)
length(unique(dat$newID))
# The variable NativeLg is to check who is a native speaker and who is not. In the practice data set, 1 is coded for YES, 2 for NO
# TASK3: Check if there are non-native speakers using the table command and extracting the information about Lang variable
################################################################################################################################
table(unique(dat[c("NativeLg", "newID")])$NativeLg)
head(dat)
sum(dat$Sentence == dat$Picture)
length(dat)
length(dat$newID)
# Condition a is a sentence without each with a collective picture
# Condition b is a sentence with each with a collective picture
# Condition c is a sentence without each with a distributive picture
# Condition d is a sentence with each with a distributive picture
# Condition e is a filler
# Condition f is a control
# You need to remove controls and fillers from the data set because you are not interested in those responses.
# Make a new copy of the data set with cleaner data
# BTW what's the best thing about Switzerland? I think it's the flag. It's a big plus. (Haha! But seriously
# read all the instructions.)
length(subset(dat, Sentence %notin% c("e", "f"))$newID)
# Condition a is a sentence without each with a collective picture
# Condition b is a sentence with each with a collective picture
# Condition c is a sentence without each with a distributive picture
# Condition d is a sentence with each with a distributive picture
# Condition e is a filler
# Condition f is a control
# You need to remove controls and fillers from the data set because you are not interested in those responses.
# Make a new copy of the data set with cleaner data
# BTW what's the best thing about Switzerland? I think it's the flag. It's a big plus. (Haha! But seriously
# read all the instructions.)
length(subset(dat, Sentence %!in% c("e", "f"))$newID)
# Condition a is a sentence without each with a collective picture
# Condition b is a sentence with each with a collective picture
# Condition c is a sentence without each with a distributive picture
# Condition d is a sentence with each with a distributive picture
# Condition e is a filler
# Condition f is a control
# You need to remove controls and fillers from the data set because you are not interested in those responses.
# Make a new copy of the data set with cleaner data
# BTW what's the best thing about Switzerland? I think it's the flag. It's a big plus. (Haha! But seriously
# read all the instructions.)
length(subset(dat, !(Sentence %in% c("e", "f")))$newID)
# Condition a is a sentence without each with a collective picture
# Condition b is a sentence with each with a collective picture
# Condition c is a sentence without each with a distributive picture
# Condition d is a sentence with each with a distributive picture
# Condition e is a filler
# Condition f is a control
# You need to remove controls and fillers from the data set because you are not interested in those responses.
# Make a new copy of the data set with cleaner data
# BTW what's the best thing about Switzerland? I think it's the flag. It's a big plus. (Haha! But seriously
# read all the instructions.)
dat = subset(dat, !(Sentence %in% c("e", "f")))
summary(dat)
# Letters used to code the conditions need to be renamed (especially because they are the same in both factors). In other words, levels of the
# factors need to be changed
# TASK 5: Use the command: levels(DATASET[,"FACTOR1"]) <- list(NAME="a", NAME="b", NAME="c", NAME="d")for both factors
# apply this formula:
# dat <- levels(dat[,"Sentence"]) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
# dat <- levels(dat[,"Picture"]) <- list(Coll="a", Coll="b", Dist="c", Dist="d")
# Check if the change was successful with summary()
dat <- levels(dat[,"Sentence"]) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
dat <- levels(dat[,"Picture"]) <- list(Coll="a", Coll="b", Dist="c", Dist="d")
summary(dat)
# Now we can remove people who didn't complete the experiment (or because we don't like them and believe they
# have weird ideas about distributivity(* just kidding!))
# To do this, you need to use the command subset, in which you make a subset of your data set and you can store it in the new vector or the same one
# but then you overwrite the old data. The advice is to save to new vector sets, just to be on the safe side.
#
# Before we try the subset command, let's make a copy of our data set.
# TASK 1: Make a copy in a new vector called "dat"
dat <- expdat
# subset the data
dat = subset(dat, newID %in% okusers)
length(unique(dat$newID))
# Condition a is a sentence without each with a collective picture
# Condition b is a sentence with each with a collective picture
# Condition c is a sentence without each with a distributive picture
# Condition d is a sentence with each with a distributive picture
# Condition e is a filler
# Condition f is a control
# You need to remove controls and fillers from the data set because you are not interested in those responses.
# Make a new copy of the data set with cleaner data
# BTW what's the best thing about Switzerland? I think it's the flag. It's a big plus. (Haha! But seriously
# read all the instructions.)
dat = subset(dat, !(Sentence %in% c("e", "f")))
levels(dat["Picture"])
levels(dat["Sentence"])
dat <- levels(dat[,"Picture"]) <- list(Coll="a", Coll="b", Dist="c", Dist="d")
levels(dat["Picture"])
summary(dat)
# Now we can remove people who didn't complete the experiment (or because we don't like them and believe they
# have weird ideas about distributivity(* just kidding!))
# To do this, you need to use the command subset, in which you make a subset of your data set and you can store it in the new vector or the same one
# but then you overwrite the old data. The advice is to save to new vector sets, just to be on the safe side.
#
# Before we try the subset command, let's make a copy of our data set.
# TASK 1: Make a copy in a new vector called "dat"
dat <- expdat
# subset the data
dat = subset(dat, newID %in% okusers)
# Condition a is a sentence without each with a collective picture
# Condition b is a sentence with each with a collective picture
# Condition c is a sentence without each with a distributive picture
# Condition d is a sentence with each with a distributive picture
# Condition e is a filler
# Condition f is a control
# You need to remove controls and fillers from the data set because you are not interested in those responses.
# Make a new copy of the data set with cleaner data
# BTW what's the best thing about Switzerland? I think it's the flag. It's a big plus. (Haha! But seriously
# read all the instructions.)
dat = subset(dat, !(Sentence %in% c("e", "f")))
summary(dat)
# Letters used to code the conditions need to be renamed (especially because they are the same in both factors). In other words, levels of the
# factors need to be changed
# TASK 5: Use the command: levels(DATASET[,"FACTOR1"]) <- list(NAME="a", NAME="b", NAME="c", NAME="d")for both factors
# apply this formula:
# dat <- levels(dat[,"Sentence"]) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
# dat <- levels(dat[,"Picture"]) <- list(Coll="a", Coll="b", Dist="c", Dist="d")
# Check if the change was successful with summary()
levels(dat[,"Sentence"]) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
levels(dat[,"Picture"]) <- list(Coll="a", Coll="b", Dist="c", Dist="d")
summary(dat)
levels(dat[,"Sentence"])
# This data set is now very neat and tidy, so it is easy to get it ready for the analysis.
#
# However, you will usually end up with a set with missing values.
# That is one of the things you need to check first.
# In R, missing values are represented by the symbol NA (not available) .
# Impossible values (e.g., dividing by zero) are represented by the symbol NaN (not a number).
# You can use is.na() to test for NA's
# Thankfully we don't have those here
is.na(dat$NativeLg)
# This data set is now very neat and tidy, so it is easy to get it ready for the analysis.
#
# However, you will usually end up with a set with missing values.
# That is one of the things you need to check first.
# In R, missing values are represented by the symbol NA (not available) .
# Impossible values (e.g., dividing by zero) are represented by the symbol NaN (not a number).
# You can use is.na() to test for NA's
# Thankfully we don't have those here
sum(is.na(dat$NativeLg))
# This data set is now very neat and tidy, so it is easy to get it ready for the analysis.
#
# However, you will usually end up with a set with missing values.
# That is one of the things you need to check first.
# In R, missing values are represented by the symbol NA (not available) .
# Impossible values (e.g., dividing by zero) are represented by the symbol NaN (not a number).
# You can use is.na() to test for NA's
# Thankfully we don't have those here
sum(is.na(dat$NativeLg))
summary(dat)
dat[is.na(dat$NativeLg),]
# Check how many people did the experiment (after the clean-up):
length(unique(dat$newID))
agedat <- subset(dat1, Age !="NA")
agedat <- subset(dat, Age !="NA")
agedat <- unique(dat[,c("newID","Age")])
describe(agedat)
library(ggplot2)
library(foreign)
library(languageR)
library(psych)
library(lme4)
library(multcomp)
describe(agedat)
agedat <- unique(dat[,c("id","Age")])
describe(dat)
agedat <- unique(dat[,c("ID","Age")])
describe(agedat)
describe(genderdat)
# Gender information
# TASK 6: Using the same formula,make a new vector genderdat (you don't have to check for NA's)
genderdat <- unique(dat[,c("newID","Gender")])
describe(genderdat)
with(genderdat,table(Gender))
length(which(genderdat$Gender =="m"))
###################################################################
#
# MEAN RATINGS
#
###################################################################
# For each Factor and factor combination see what the rating was.
# If you type this you'll get the mean and the sd and se for each factor combination.
# with(dat, describeBy(DEP_VAR, list(FACTOR_1, FACTOR_2)))
with(dat, describeBy(Answer, list(Gender, Age)))
###################################################################
#
# MEAN RATINGS
#
###################################################################
# For each Factor and factor combination see what the rating was.
# If you type this you'll get the mean and the sd and se for each factor combination.
# with(dat, describeBy(DEP_VAR, list(FACTOR_1, FACTOR_2)))
with(dat, describeBy(Answer, list(Gender, Sentence)))
# TASK 7: decide which variables need to be factors in the practice data set and convert them.
# TIP: Use str() to get the overview what is a factor and what is not. Don't forget to define items and subjects as (random) factors too
# Question: Is age a factor? In other words is there any relationship between `21 years` and `22 years` or is it just catogorical (like colors)?
# I'll give you the answer: it is numeric. Because 21 is less old than 22. This means that Age has to be num: dat$FACTOR <- as.numeric(dat$FACTOR)
tmpdat <- dat
tmpdat$Sentence <- as.factor(dat$Sentence)
summary(tmpdat)
# TASK 7: decide which variables need to be factors in the practice data set and convert them.
# TIP: Use str() to get the overview what is a factor and what is not. Don't forget to define items and subjects as (random) factors too
# Question: Is age a factor? In other words is there any relationship between `21 years` and `22 years` or is it just catogorical (like colors)?
# I'll give you the answer: it is numeric. Because 21 is less old than 22. This means that Age has to be num: dat$FACTOR <- as.numeric(dat$FACTOR)
tmpdat <- dat
tmpdat$Sentence <- as.factor(dat$Sentence, levels=list(Coll="a", Coll="b", Dist="c", Dist="d"))
# TASK 7: decide which variables need to be factors in the practice data set and convert them.
# TIP: Use str() to get the overview what is a factor and what is not. Don't forget to define items and subjects as (random) factors too
# Question: Is age a factor? In other words is there any relationship between `21 years` and `22 years` or is it just catogorical (like colors)?
# I'll give you the answer: it is numeric. Because 21 is less old than 22. This means that Age has to be num: dat$FACTOR <- as.numeric(dat$FACTOR)
tmpdat <- dat
tmpdat$Sentence <- as.factor(dat$Sentence, levels=list(Coll="a", Coll="b", Dist="c", Dist="d"))
tmpdat$Sentence <- as.factor(dat$Sentence)
levels(dat[,"Sentence"]) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
summary(tmpdat)
levels(dat[,"Sentence"])
levels(dat$Sentence)
levels(dat$Sentence) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
summary(tmpdat)
# TASK 7: decide which variables need to be factors in the practice data set and convert them.
# TIP: Use str() to get the overview what is a factor and what is not. Don't forget to define items and subjects as (random) factors too
# Question: Is age a factor? In other words is there any relationship between `21 years` and `22 years` or is it just catogorical (like colors)?
# I'll give you the answer: it is numeric. Because 21 is less old than 22. This means that Age has to be num: dat$FACTOR <- as.numeric(dat$FACTOR)
tmpdat <- dat
levels(dat$Sentence) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
summary(tmpdat)
tmpdat$Sentence <- as.factor(dat$Sentence)
is.factor(dat$Sentence)
tmpdat$Sentence <- as.factor(dat$Sentence)
is.factor(dat$Sentence)
levels(tmpdat$Sentence) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
summary(tmpdat)
tmpdat$Sentence <- as.factor(dat$Sentence)
levels(tmpdat$Sentence) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
summary(tmpdat)
is.factor(tmpdat$Sentence)
# TASK 7: decide which variables need to be factors in the practice data set and convert them.
# TIP: Use str() to get the overview what is a factor and what is not. Don't forget to define items and subjects as (random) factors too
# Question: Is age a factor? In other words is there any relationship between `21 years` and `22 years` or is it just catogorical (like colors)?
# I'll give you the answer: it is numeric. Because 21 is less old than 22. This means that Age has to be num: dat$FACTOR <- as.numeric(dat$FACTOR)
dat$Sentence <- as.factor(dat$Sentence)
dat$Picture <- as.factor(dat$Picture)
is.factor(dat$Sentence)
summary(dat)
dat$Age <- as.numeric(dat$Age)
summary(dat)
dat$Item
dat$NativeLg <- as.factor(dat$NativeLg)
dat$Gender <- as.factor(dat$Gender)
dat$Item <- as.factor(dat$Item)
summary(dat)
head(dat)
dat$Answer <- as.factor(dat$Answer)
summary(dat)
dat$newID <- as.factor(dat$newID)
dat$ID <- as.factor(dat$ID)
summary(dat)
length(unique(dat$newID))
table(dat$newID)
# TASK 8: Check if they are factors using is.factor()
is.factor(dat)
$Sentence
# TASK 8: Check if they are factors using is.factor()
is.factor(dat$Sentence)
summary(dat)
######################################################################################################
# How many lists are done? use table(). This is just to get an overview of the balance between lists
table(dat$Qnum)
######################################################################################################
# How many lists are done? use table(). This is just to get an overview of the balance between lists
table(dat)
######################################################################################################
# How many lists are done? use table(). This is just to get an overview of the balance between lists
table(dat$newID)
######################################################################################################
# How many lists are done? use table(). This is just to get an overview of the balance between lists
table(table(dat$newID))
response.mean <- with(dat,aggregate(list(DEP_VAR="Answer"),list(FACTOR1="Sentence", FACTOR2="Age"),mean))
response.mean <- with(dat,aggregate(list(DEP_VAR=Answer),list(FACTOR1=Sentence, FACTOR2=Age),mean))
#response.mean <-
with(dat,aggregate(list(DEP_VAR=Answer),list(FACTOR1=Sentence, FACTOR2=Age),mean))
response.mean <- with(dat,aggregate(list(DEP_VAR=dat$Answer),list(FACTOR1=dat$Sentence, FACTOR2=dat$Age),mean))
response.mean <- with(dat,aggregate(list(DEP_VAR=Answer),list(FACTOR1=Sentence, FACTOR2=Age),mean))
response.mean <- with(dat,aggregate(list(DEP_VAR=Answer),list(FACTOR1=Sentence, FACTOR2=Picture),mean))
response.mean <- with(dat,aggregate(list(DEP_VAR="Answer"),list(FACTOR1=Sentence, FACTOR2=Picture),mean))
response.mean <- with(dat,aggregate(list(DEP_VAR="Answer"),list(FACTOR1="Sentence", FACTOR2="Picture"),mean))
response.mean <- with(dat,aggregate(list(DEP_VAR=dat$Answer),list(FACTOR1=dat$Sentence, FACTOR2=dat$Picture),mean))
response.mean <- with(dat,aggregate(list(DEP_VAR=dat$Answer),list(FACTOR1=dat$Age, FACTOR2=dat$Age),mean))
response.mean <- with(dat,aggregate(list(DEP_VAR=dat$Answer),list(FACTOR1=dat$Sentence, FACTOR2=dat$Age),mean))
# You can check the means per subject to see if there are some weird participants that you need to exclude
aggregate(dat$DEP_VAR, by=list(dat$SUBJECTS, dat$Age, dat$Sentence), mean)
# You can check the means per subject to see if there are some weird participants that you need to exclude
aggregate(dat$DEP_VAR, by=list(dat$Answer, dat$Age, dat$Sentence), mean)
summary(dat)
response.mean <- with(dat,aggregate(list(DEP_VAR=dat$Answer),list(FACTOR1=dat$Sentence, FACTOR2=dat$Age),mean))
warnings()
response.mean <- with(dat,aggregate(list(dat$Answer),list(dat$Sentence, dat$Age),mean))
warnings()
is.factor(dat$Answer)
is.factor(dat$Sentence)
is.numeric(dat$Age)
dat$Answer <- as.logical(dat$Answer)
source('~/rug-student/language_modelling/lab1/Lab1_LgMod_2019.R', echo=TRUE)
install.packages("ggplot2", "foreign", "languageR", "psych", "lme4", "multcomp")
# Now we can remove people who didn't complete the experiment (or because we don't like them and believe they
# have weird ideas about distributivity(* just kidding!))
# To do this, you need to use the command subset, in which you make a subset of your data set and you can store it in the new vector or the same one
# but then you overwrite the old data. The advice is to save to new vector sets, just to be on the safe side.
#
# Before we try the subset command, let's make a copy of our data set.
# TASK 1: Make a copy in a new vector called "dat"
dat <- expdat
names(expdat)
dat$ID
# check which user got up to 48-5th question
# an alternative solution would be to use table but that's not straightforward because if someone tried the experiment twice up to question 25,
# then they did not answer most of the questions (see dat[dat$newID == 1,])
okusers = unique(dat[(dat$Qnum == 48-5),]$newID)
# number of all users
length(unique(dat$newID))
# number of ok users
length(okusers)
# number of incomplete users
length(unique(dat$newID)) - length(okusers)
# manual check for one user (e.g. 68)
setdiff(unique(dat$newID), okusers)
dat[dat$newID == 68,]
# subset the data
dat = subset(dat, newID %in% okusers)
length(unique(dat$newID))
# The variable NativeLg is to check who is a native speaker and who is not. In the practice data set, 1 is coded for YES, 2 for NO
# TASK3: Check if there are non-native speakers using the table command and extracting the information about Lang variable
################################################################################################################################
table(unique(dat[c("NativeLg", "newID")])$NativeLg)
# Condition a is a sentence without each with a collective picture
# Condition b is a sentence with each with a collective picture
# Condition c is a sentence without each with a distributive picture
# Condition d is a sentence with each with a distributive picture
# Condition e is a filler
# Condition f is a control
# You need to remove controls and fillers from the data set because you are not interested in those responses.
# Make a new copy of the data set with cleaner data
# BTW what's the best thing about Switzerland? I think it's the flag. It's a big plus. (Haha! But seriously
# read all the instructions.)
dat = subset(dat, !(Sentence %in% c("e", "f")))
summary(dat)
# Letters used to code the conditions need to be renamed (especially because they are the same in both factors). In other words, levels of the
# factors need to be changed
# TASK 5: Use the command: levels(DATASET[,"FACTOR1"]) <- list(NAME="a", NAME="b", NAME="c", NAME="d")for both factors
# apply this formula:
# dat <- levels(dat[,"Sentence"]) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
# dat <- levels(dat[,"Picture"]) <- list(Coll="a", Coll="b", Dist="c", Dist="d")
# Check if the change was successful with summary()
levels(dat[,"Sentence"]) <- list(No_Each="a", Each="b", No_Each="c", Each="d")
levels(dat[,"Picture"]) <- list(Coll="a", Coll="b", Dist="c", Dist="d")
summary(dat)
# This data set is now very neat and tidy, so it is easy to get it ready for the analysis.
#
# However, you will usually end up with a set with missing values.
# That is one of the things you need to check first.
# In R, missing values are represented by the symbol NA (not available) .
# Impossible values (e.g., dividing by zero) are represented by the symbol NaN (not a number).
# You can use is.na() to test for NA's
# Thankfully we don't have those here (??????)
sum(is.na(dat$NativeLg))
dat[is.na(dat$NativeLg),]
# Check how many people did the experiment (after the clean-up):
length(unique(dat$newID))
agedat <- subset(dat, Age !="NA")
agedat <- unique(dat[,c("newID","Age")])
describe(agedat)
# Gender information
# TASK 6: Using the same formula,make a new vector genderdat (you don't have to check for NA's)
genderdat <- unique(dat[,c("newID","Gender")])
with(genderdat,table(Gender))
length(which(genderdat$Gender =="m"))
###################################################################
#
# MEAN RATINGS
#
###################################################################
# For each Factor and factor combination see what the rating was.
# If you type this you'll get the mean and the sd and se for each factor combination.
# with(dat, describeBy(DEP_VAR, list(FACTOR_1, FACTOR_2)))
with(dat, describeBy(Answer, list(Gender, Sentence)))
# TASK 7: decide which variables need to be factors in the practice data set and convert them.
# TIP: Use str() to get the overview what is a factor and what is not. Don't forget to define items and subjects as (random) factors too
# Question: Is age a factor? In other words is there any relationship between `21 years` and `22 years` or is it just catogorical (like colors)?
# I'll give you the answer: it is numeric. Because 21 is less old than 22. This means that Age has to be num: dat$FACTOR <- as.numeric(dat$FACTOR)
dat$Sentence <- as.factor(dat$Sentence)
dat$Picture <- as.factor(dat$Picture)
dat$NativeLg <- as.factor(dat$NativeLg)
dat$Gender <- as.factor(dat$Gender)
dat$Item <- as.factor(dat$Item)
dat$Answer <- as.logical(dat$Answer)
dat$newID <- as.factor(dat$newID)
dat$ID <- as.factor(dat$ID)
dat$Age <- as.numeric(dat$Age)
summary(dat)
# TASK 8: Check if they are factors using is.factor()
is.factor(dat$Sentence)
######################################################################################################
# How many lists are done? use table(). This is just to get an overview of the balance between lists
table(table(dat$newID))
response.mean <- with(dat,aggregate(list(DEP_VAR=dat$Answer),list(FACTOR1=dat$Sentence, FACTOR2=dat$Age),mean))
response.mean
# Let's look at the aggregated results
response.mean
# You can check the means per subject to see if there are some weird participants that you need to exclude
aggregate(dat$Answer, by=list(dat$newID, dat$Sentence, dat$Age), mean)
table(dat$Sentence, dat$newID, dat$Age, dat$Answer)
with(dat,table(dat$Answer, dat$Sentence, dat$Age))
with(dat,table(dat$Answer, dat$Sentence, dat$Gender))
dat$Age
response.mean <- with(dat,aggregate(list(DEP_VAR=dat$Answer),list(FACTOR1=dat$Sentence, FACTOR2=dat$Gender),mean))
# Let's look at the aggregated results
response.mean
describeBy(dat$Answer, list(dat$Sentence, dat$Gender), mat=TRUE,digits=2)
library(ggplot2)
se = c() #fill in the se values, start from the value that is on the first bar (left-most bar)
limits <- aes(ymax = Answer + se, ymin=Answer - se)
dodge <- position_dodge(width=0.9)
ggplot(MEANS, aes(factor(dat$Sentence), Answer, fill = dat$Gender)) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean, aes(factor(dat$Sentence), Answer, fill = dat$Gender)) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean, aes(factor(dat$Sentence), dat$Answer, fill = dat$Gender)) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean, aes(factor("Gender"), Answer, fill = "Sentence")) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean, aes(factor("Gender"), "Answer", fill = "Sentence")) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean, aes(factor("FACTOR1"), dat$Answer, fill = "FACTOR2")) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
response.mean
limits <- aes(ymax = dat$Answer + se, ymin=dat$Answer - se)
ggplot(response.mean) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean, aes(factor("FACTOR1"), dat$Answer, fill = "FACTOR2")) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean, aes(factor("FACTOR1"), dat$Answer, fill = "FACTOR2")) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
ggplot(response.mean, aes(factor(dat$Sentence), dat$Answer, fill = dat$Gender)) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
se = c(0,0,0) #fill in the se values, start from the value that is on the first bar (left-most bar)
limits <- aes(ymax = dat$Answer + se, ymin=dat$Answer - se)
dodge <- position_dodge(width=0.9)
ggplot(response.mean, aes(factor(dat$Sentence), dat$Answer, fill = dat$Gender)) +
geom_bar(stat="identity", position = "dodge") + geom_errorbar(limits, position=dodge, width=0.25)+
scale_fill_brewer(palette = "Set3")
